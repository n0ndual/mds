* 内存数据库的设计
** 事件驱动框架，实现一个简单server
** 实现简单的数据结构，key-value结构，要考虑到性能
** 实现简单的协议，包括客户端和服务器
** 实现集群功能，master-slave架构或者dht
** 实现rdb或者aof功能（可选）
** 提供一个接口方法，可以故障恢复

* 一致性
lamport算法确保一致性
但是不保证可用性
** 出现n台机器故障时，能否保证一致性

* 可用性
** 停机时间的约束：发生故障时停机多久
** 响应时间的约束：无故障平均响应时间和故障时平均响应时间，响应时间方差
** 从用户的角度看可用性，某个节点挂了后，必然会停机一段时间，直到找到另一个节点。

* 容错性
** 出现n台机器故障时，依然可用，且数据保持一致

* CAP问题的本质
** 容错保障可用性：
n个机器的集群中，发生k个故障时，是否能保证集群不停机，或者在短暂停机后继续可用。是否能保证数据依然是一致的。
** 容错保障一致性：
数据一致性的定义，如果告诉客户某个操作成功，那么最终使该操作在整个集群中成功。

* CAP问题困难的原因：
缺少网络模型和故障模型，使得无法量化可用性和容错性

* CAP是否真的是一个定理：
** 不停机和正常情况最优的可用性和实时一致性是不兼容的
** 不停机和正常情况最优的可用性和最终一致性是兼容的
** 暂停容忍和正常最优可用性和实时一致性是兼容的
** 暂停容忍和正常最优可用性和实时一致性是兼容的

* 网络故障模型？
既要考虑延迟，又要考虑故障导致分区，但没有数学模型；

* 分析：
所有机器都作为proposer和leaner，容错性和一致性很好，但是延迟高。

simple-paxos 正常工作时，延迟是最低的；但存在单点故障；单点故障时重选master；
为了解决单点故障，增加proposer，正常工作时不是最优的；

多个distinguished proposer和distinguished learner的情况下，极大的增加了达成一致需要的时间；增加了正常工作时的延迟；
多个distinguished proposer和distinguished learner的情况下，如果降低至最终一致性，正常情况下的延迟是最优的，而且不存在单点故障。

如何提供一个框架，使得分布式系统开发者可以直接选择自己的CAP策略，是非常有价值的。

* 最佳策略：
** 实现方式
正常工作时使用单master；master故障时，进入全proposer阶段，同时进行重选master；保持了一致性，正常工作时最优，故障时不停机；
故障时，进入全proposer，全learner模式，非常慢；
** 缺点：
master的压力大；每一个读写请求都要与master至少通信一次；
** 优化：
one distinguished proposer, multiple distinguished learner等价于把请求都路由给master

* 框架：
raft算法：
选举算法
master故障时重选master，同时退化到paxos算法；无master的paxos算法是有可能死锁的。
增加或者删除节点时，确保一致性；

现实中的分布式系统不仅仅是一个分布式状态机，而是状态机+计算

* 遗留问题
** 负载均衡与容错？
某一个节点故障后，client如何联系其他节点
mysql数据库的主从复制
mysql数据库的故障恢复
mysql数据库的单点故障
** 永远不停机的情况不存在
因为与client交互的是某一太机器，这台机器故障后，client必须能找到另一台机器来交互。

* 总结
CAP没有意义
设计一个分布式系统，应当先有一个应用或者目标，然后寻找解决方法。

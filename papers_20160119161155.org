* MapReduce and MPI
** why is MapReduce attractive
*** plus
**** write only code that only you can write
**** write zero parallel code
**** out-of-core for free
*** Plus/Minus
**** ignore data locality
**** load balance thru random distribution
**** maximazie communication
*** Minus
**** hava to re-cast your algorithm as Map-Reduce
*** conclution:
good programming model for big data analyst:
not maximal performance, but minimal human effort
** no-one runs hadoop on huge HPC clusters(as far as i know)
** MR-MPI: http://mapreduce.sandia.gov
*** MapReduce on top of MPI
*** lightweight, portable, C++ library with C API
*** out-of-core on big iron if each proc can write scratch files
*** no HDFS
*** no fault-tolerance (blame it on MPI)
** post-simulation analysis
*** on HPC platform, don't have to move your data
*** computations needing info from entire time series

* why do scala developers mix the Actor model with other concurrency models?
** ECOOP 2013, 24 citation
** Abstract
*** disadvantages
**** break the actor abstraction: This increases the chance of creating deadlocks and data races—two mistakes that are hard to make with actors.
**** Furthermore, it prevents the use of many advanced testing, modeling, and verification tools for actors, as these require pure actor programs.
*** motivation
**** This study is the first to point out the phenomenon of mixing concurrency models by Scala developers and to systematically identify the factors leading to it. We studied 15 large, mature, and actively maintained actor programs written in Scala and found that 80% of them mix the actor model with another concurrency model.
**** Consequently, a large part of real-world actor programs does not use actors to their fullest advantage.
*** conclusion/contribution
**** Inspection of the programs and discussion with the developers reveal two reasons for mixing that can be influenced by researchers and library-builders: weaknesses in the actor library implementations, and shortcomings of the actor model itself.
** Introduction
*** Actor's main advantage
**** The model’s restriction of communication to asynchronous message-passing simplifie sreasoning about concurrency, guarantees scalability, allows distributing the program over the network, and enables efficient tools for testing [17,32], modeling [30] and verifying [33] actor programs.
*** Motivation
**** This raised the question why programmers gave up the advantages of actors and mixed them with threads. Was it a temporary measure, as the programmers converted thread-based parallelism to actors? Does this indicate problems with the actor model, with the implementation of the actor libraries for Scala, or in the education of Scala programmers?
*** Three Questions:
**** RQ1. How often do Scala programmers mix actors with other kinds of concurrent entities? This question obviously goes far beyond Scala, but we decided to look first at Scala before looking at other languages
**** RQ2. How many of the programs are distributed over the network, and does distribution influence the way programmers mix concurrency models? Our motivation for this question is that the actor model can be used to exploit multiple local processors, as well as to distribute the program over the network. Hence, one reason for mixing concurrency models could be that some models are better for particular kinds of programming than others.
**** RQ3. How often do the actors in the programs use communication mechanisms other than asynchronous messaging? Communication through asynchronous messaging reduces the possibility of deadlock and data races, which are common problems in the shared-memory model. However, in Scala, actors can also communicate via other mechanisms such as shared locks.
*** Methodology
**** This paper describes how we selected programs to study
**** the way we measured them, the resulting measurements (Section 4), and the conclusions we drew.
**** We also contacted the developers, and they provided many insights into the meaning of our observations
**** Our findings (Section 6) reveal that the reasons for mixing the actor model with other concurrency models are mostly due to weaknesses in the implementations of the libraries. However, they also show weaknesses in the actor model itself, as well as in the experience of developers.
*** Contributions
**** 1. It is the first to point out the phenomenon of Scala developers mixing theactor model with other concurrency models.
**** 2. It gives statistics about mixing actors with other kinds of concurrent entities in real-world Scala programs.
**** 3. It gives recommendations for researchers and actor-library designers.
** section 4: Results
*** RQ1: How Often Do Scala Programmers Mix Actors with other Kinds of Concurrent Entities?
**** The results in Table 2 show that 13 of the 16 programs (81%) mix concurrent entities and 12 of the 15 programs (80%) mix Actor with Runnable or Future.
**** It is therefore not surprising to find that 8 out of 15 programs (53%) that use actors also use futures.
**** In Table 2, 10 out of 15 programs (66%) use both Actor and Runnable.
*** RQ2: How Many of the Programs are Distributed over the Network, and Does Distribution Influence the Way Programmers Mix Concurrency Models?
**** Only 3 out of 16 programs use actors for remote deployment
**** 7 out of the 16 programs are distributed
**** This implies that developers tend to use other ways than remote actors for implementing distributed computations.
*** RQ3: How Often Do the Actors in the Programs Use Communication Mechanisms other Than Asynchronous Messaging?
**** (1) Non-blocking operations like sending asynchronous messages (sm); resolving a future (rf); and signaling a synchronization construct (ss), for example counting down a latch or releasing a lock.
**** (2) Blocking operations like waiting to receive a message from a channel (wm); waiting for a future to be resolved (wf); and waiting for a synchronization construct to be signaled (ws), for example waiting on a latch.
**** (3) Other operations that do not fit in either of the above categories, for example communication via external resources like files or shared objects that are not synchronization constructs.
**** in at least 9 out of 15 programs (60%), actors use communication mechanisms other than asynchronous messaging
** Section 5: The Reasons for Mixing Concurrency Models
*** Actor library inadequacies
**** Efficient I/O
**** Spark: Spark is a distributed computation framework that needs to exchange large blocks of data over the network. Because the developers are unsure about the actor library’s performance regarding large data transfer, they spawn dedicated threads for handling this task.
**** “[...] in ParallelShuffleFetcher, we are receiving large blocks of datafrom multiple machines. Most actor libraries don’t deal well with thatthey are optimized for transferring small messages (up to a few hundred bytes) [...], and they might have a small number of IO threads that block when you’re sending something bigger. In this case, instead of worryingabout whether the actor library will handle the transfer well [...] and whether it will affect other messages being sent by other actors, we chose to explicitly spawn threads. I’d love an actor library that also handleslarge IOs, or exposes asynchronous IO primitives, but I haven’t foundone.”
**** Low-End Systems.
**** Managing and Debugging Many Blocking Operations
**** Customized Actors.
*** Actor model inadequacies
**** The example shows that implementing some coordination protocols in the actor model can be more complex than using a shared-memory model. The developers may need to add extra variables and implement more complex logic to handle the asynchrony in the actor model that is not present in the sharedmemory model. Specifically, for developers who are new to the actor model, understanding and managing coordination in an asynchronous and no-shared state model might be harder than in the shared-memory model.
**** To address this problem, prior work has extended the Scala actor library with coordination patterns used in parallel programming, for example joins [12] and divide-and-conquer tasks [15]. More advanced coordination mechanisms for actor systems have also been proposed [4,31,9,27]. However,to the best of our knowledge, none has been integrated with a widely used actor library.
*** Inadequate developer experience
** Section 6: Implications and Discussion
*** Implications for Researchers
**** Each model has its strengths, and developers tend to use the model that best fits the problem.
**** However, the current implementations of actors in the Scala standard library and Akka force developers to use models other than actors to meet the application requirements.
**** Specifically, mixtures of Actor and Future are common, as they help implementing coordination between the purely asynchronous actors.
**** On the other hand, the results show that in three cases, mixing actors with threads is unnecessary.
**** The actor model itself also puts a burden on developers. The property of no shared state and asynchronous communication can make implementing coordination protocols harder than using established constructs like locks.
*** Implications for Library Developers:
**** First, the API can provide commonly required features like modules for efficiently handling or customizing I/O.
**** Second, it can prevent developers from misusing the library constructs and violating best practices. For example, if messages were restricted to immutabletypes, actors could not easily share objects by exchanging references through messages. While libraries cannot completely prevent shared state in actors, such a limitation would push developers towards using a proper design.
** Section 8: Related Work
*** Another line of work integrates the actor model with task parallelism. Haller et al. [12] augment the Scala actor library with join patterns. PAM [29] adds parallel execution of messages inside of actors to achieve better performance. JCoBox [28] combines actors and futures to implement parallel execution of tasks and synchronous messaging. Immam et al. [15] propose a unified parallel programming model for Scala and Java that integrates the actor model with the divide-and-conquer task parallel model.
*** These works use small benchmarks to show that implementing certain protocols with their proposed model is easier and can provide better performance than the pure actor model.
*** However, none of these works conducts any study on real-world programs to show the weaknesses of the actor libraries or the actor model. Our study complements these works by supplying the empirical evidence for these weaknesses.
** Section 9: Future Work:
*** A direction for future work is to correlate the phenomenon of mixing concurrency models with bug rates and types.
*** A related question is whether mixing occurs across different layers of abstraction. For example, mixing may occur only on the lower, more concrete layers of the program while actors prevail on the higher, more abstract layers.
*** Finally, it would be interesting to see how different actor libraries for the same language, for example Scala, affect the design decisions of programmers.

* Actor Frameworks for the JVM platform
** PPPJ '09, 127 citations
** Introduction
*** researchers and practitioners have shown an increasing interest in using actor-oriented programming.
*** Ed Lee [2] has argued that in adopting a new language or library, programmers are motivated as much by its syntax as by its semantics.
*** Perhaps for this reason, despite the development of a number of novel Actor languages, there continue to be efforts to develop Actor frameworks based on familiar languages such as C/C++ (Act++ [8], Broadway [9], Thal [10]), Smalltalk (Actalk [11]), Python (Stackless Python [12], Parley [13]), Ruby (Stage [14]), .NET (Microsoft’s Asynchronous Agents Library [15], Retlang [16]) and Java (Scala Actors library [17], Kilim [18], Jetlang [19], ActorFoundry [20], Actor Architecture [21], Actors Guild [22], JavAct [23], AJ [24], and Jsasb [25]).
*** As mentioned earlier, many actor-oriented frameworks compromise one or more of the semantic properties of actors. We discuss the significance of each of these properties in or-11 der to understand the impact of compromising the property from the “ease of programming” point of view
*** We then describe some common communication and synchronization abstractions in actor frameworks
*** Finally, we analyze the implementation mechanisms in Actor frameworks and study how the cost of providing actor properties may be mitigated
*** Our analysis suggests that while a na¨ıve implementationof actor properties may be highly inefficient, a sophisticated implementation of actor framework on JVM may provide efficient execution without compromising essential actor properties.
*** The main contribution of this paper is to provide a basis for understanding how various actor frameworks differ, both from a programmability point of view, and from a performance point of view. We hope that the results will guide developers in selecting a suitable framework and facilitate in the development of other actor-oriented frameworks.
* dominant resource fairness: fair allocation of multiple resource types
** 跟我们的需求的不同点：
*** 最关注的是公平和效率
** 公有云的需求：
*** 资源一定是够用的
*** 资源一定是
** asset allocation
*** allocation of every kind of resource may be less than 1/n
**** xa+by=1/n(Ax+By)
**** a<1/nA
**** b<1/nB
* review: service-oriented multi-tenancy: Enabling Multi-tenancy for Existing Service Composition Engines with Docker?
** overrall evaluation:
0: borderline paper
** reviewer's confidence
3: medium
** Review
*** With the rise of the cloud, companies need to outsourcing service hosting to cloud providers. However, exsisting BPEL engines do not provide the multi-tenancy features that are required for cloud providers. There are mainly two approaches to address this questiong: multi-instance multi-tenancy and single-instance multi-instance.
*** This paper proposed a new approach by hosting each service in its own Linux container. But why each service should be isolated in its own container is not explained. Isolating each tenant in its own VMs seems enough.
*** the main contribution of this paper is a optimized docker image that containes just enough things to run apache ODE without its web ui. The experiment shows that using this docker image saves resources compared to the default service runtime stack while being faster. Based on this experiment, this paper oncludes that this approach is able to be used as a multi-tenancy approach. This statement should be backed by experiments that compare SO-MT with single-instance multi-instance and single-instance multi-tenancy which are not presented in this paper.

* review: Threat Modeling for Services in Cloud
** overall evaluation:
0: borderline paper
** reviewer's confidence
3: medium
** Review
*** this paper claims that on work has been specifically done for modeling threats to cloud services and the data processed by services, but why specific work need to be done for cloud services are not clearly explained. this paper describes various threats to cloud service which seems not only exist in cloud computing area. the work of this paper seems trivial.

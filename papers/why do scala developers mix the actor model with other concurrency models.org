* why do scala developers mix the Actor model with other concurrency models?
** ECOOP 2013, 24 citation
** Abstract
*** disadvantages
**** break the actor abstraction: This increases the chance of creating deadlocks and data races—two mistakes that are hard to make with actors.
**** Furthermore, it prevents the use of many advanced testing, modeling, and verification tools for actors, as these require pure actor programs.
*** motivation
**** This study is the first to point out the phenomenon of mixing concurrency models by Scala developers and to systematically identify the factors leading to it. We studied 15 large, mature, and actively maintained actor programs written in Scala and found that 80% of them mix the actor model with another concurrency model.
**** Consequently, a large part of real-world actor programs does not use actors to their fullest advantage.
*** conclusion/contribution
**** Inspection of the programs and discussion with the developers reveal two reasons for mixing that can be influenced by researchers and library-builders: weaknesses in the actor library implementations, and shortcomings of the actor model itself.
** Introduction
*** Actor's main advantage
**** The model’s restriction of communication to asynchronous message-passing simplifie sreasoning about concurrency, guarantees scalability, allows distributing the program over the network, and enables efficient tools for testing [17,32], modeling [30] and verifying [33] actor programs.
*** Motivation
**** This raised the question why programmers gave up the advantages of actors and mixed them with threads. Was it a temporary measure, as the programmers converted thread-based parallelism to actors? Does this indicate problems with the actor model, with the implementation of the actor libraries for Scala, or in the education of Scala programmers?
*** Three Questions:
**** RQ1. How often do Scala programmers mix actors with other kinds of concurrent entities? This question obviously goes far beyond Scala, but we decided to look first at Scala before looking at other languages
**** RQ2. How many of the programs are distributed over the network, and does distribution influence the way programmers mix concurrency models? Our motivation for this question is that the actor model can be used to exploit multiple local processors, as well as to distribute the program over the network. Hence, one reason for mixing concurrency models could be that some models are better for particular kinds of programming than others.
**** RQ3. How often do the actors in the programs use communication mechanisms other than asynchronous messaging? Communication through asynchronous messaging reduces the possibility of deadlock and data races, which are common problems in the shared-memory model. However, in Scala, actors can also communicate via other mechanisms such as shared locks.
*** Methodology
**** This paper describes how we selected programs to study
**** the way we measured them, the resulting measurements (Section 4), and the conclusions we drew.
**** We also contacted the developers, and they provided many insights into the meaning of our observations
**** Our findings (Section 6) reveal that the reasons for mixing the actor model with other concurrency models are mostly due to weaknesses in the implementations of the libraries. However, they also show weaknesses in the actor model itself, as well as in the experience of developers.
*** Contributions
**** 1. It is the first to point out the phenomenon of Scala developers mixing theactor model with other concurrency models.
**** 2. It gives statistics about mixing actors with other kinds of concurrent entities in real-world Scala programs.
**** 3. It gives recommendations for researchers and actor-library designers.
** section 4: Results
*** RQ1: How Often Do Scala Programmers Mix Actors with other Kinds of Concurrent Entities?
**** The results in Table 2 show that 13 of the 16 programs (81%) mix concurrent entities and 12 of the 15 programs (80%) mix Actor with Runnable or Future.
**** It is therefore not surprising to find that 8 out of 15 programs (53%) that use actors also use futures.
**** In Table 2, 10 out of 15 programs (66%) use both Actor and Runnable.
*** RQ2: How Many of the Programs are Distributed over the Network, and Does Distribution Influence the Way Programmers Mix Concurrency Models?
**** Only 3 out of 16 programs use actors for remote deployment
**** 7 out of the 16 programs are distributed
**** This implies that developers tend to use other ways than remote actors for implementing distributed computations.
*** RQ3: How Often Do the Actors in the Programs Use Communication Mechanisms other Than Asynchronous Messaging?
**** (1) Non-blocking operations like sending asynchronous messages (sm); resolving a future (rf); and signaling a synchronization construct (ss), for example counting down a latch or releasing a lock.
**** (2) Blocking operations like waiting to receive a message from a channel (wm); waiting for a future to be resolved (wf); and waiting for a synchronization construct to be signaled (ws), for example waiting on a latch.
**** (3) Other operations that do not fit in either of the above categories, for example communication via external resources like files or shared objects that are not synchronization constructs.
**** in at least 9 out of 15 programs (60%), actors use communication mechanisms other than asynchronous messaging
** Section 5: The Reasons for Mixing Concurrency Models
*** Actor library inadequacies
**** Efficient I/O
**** Spark: Spark is a distributed computation framework that needs to exchange large blocks of data over the network. Because the developers are unsure about the actor library’s performance regarding large data transfer, they spawn dedicated threads for handling this task.
**** “[...] in ParallelShuffleFetcher, we are receiving large blocks of datafrom multiple machines. Most actor libraries don’t deal well with thatthey are optimized for transferring small messages (up to a few hundred bytes) [...], and they might have a small number of IO threads that block when you’re sending something bigger. In this case, instead of worryingabout whether the actor library will handle the transfer well [...] and whether it will affect other messages being sent by other actors, we chose to explicitly spawn threads. I’d love an actor library that also handleslarge IOs, or exposes asynchronous IO primitives, but I haven’t foundone.”
**** Low-End Systems.
**** Managing and Debugging Many Blocking Operations
**** Customized Actors.
*** Actor model inadequacies
**** The example shows that implementing some coordination protocols in the actor model can be more complex than using a shared-memory model. The developers may need to add extra variables and implement more complex logic to handle the asynchrony in the actor model that is not present in the sharedmemory model. Specifically, for developers who are new to the actor model, understanding and managing coordination in an asynchronous and no-shared state model might be harder than in the shared-memory model.
**** To address this problem, prior work has extended the Scala actor library with coordination patterns used in parallel programming, for example joins [12] and divide-and-conquer tasks [15]. More advanced coordination mechanisms for actor systems have also been proposed [4,31,9,27]. However,to the best of our knowledge, none has been integrated with a widely used actor library.
*** Inadequate developer experience
** Section 6: Implications and Discussion
*** Implications for Researchers
**** Each model has its strengths, and developers tend to use the model that best fits the problem.
**** However, the current implementations of actors in the Scala standard library and Akka force developers to use models other than actors to meet the application requirements.
**** Specifically, mixtures of Actor and Future are common, as they help implementing coordination between the purely asynchronous actors.
**** On the other hand, the results show that in three cases, mixing actors with threads is unnecessary.
**** The actor model itself also puts a burden on developers. The property of no shared state and asynchronous communication can make implementing coordination protocols harder than using established constructs like locks.
*** Implications for Library Developers:
**** First, the API can provide commonly required features like modules for efficiently handling or customizing I/O.
**** Second, it can prevent developers from misusing the library constructs and violating best practices. For example, if messages were restricted to immutabletypes, actors could not easily share objects by exchanging references through messages. While libraries cannot completely prevent shared state in actors, such a limitation would push developers towards using a proper design.
** Section 8: Related Work
*** Another line of work integrates the actor model with task parallelism. Haller et al. [12] augment the Scala actor library with join patterns. PAM [29] adds parallel execution of messages inside of actors to achieve better performance. JCoBox [28] combines actors and futures to implement parallel execution of tasks and synchronous messaging. Immam et al. [15] propose a unified parallel programming model for Scala and Java that integrates the actor model with the divide-and-conquer task parallel model.
*** These works use small benchmarks to show that implementing certain protocols with their proposed model is easier and can provide better performance than the pure actor model.
*** However, none of these works conducts any study on real-world programs to show the weaknesses of the actor libraries or the actor model. Our study complements these works by supplying the empirical evidence for these weaknesses.
** Section 9: Future Work:
*** A direction for future work is to correlate the phenomenon of mixing concurrency models with bug rates and types.
*** A related question is whether mixing occurs across different layers of abstraction. For example, mixing may occur only on the lower, more concrete layers of the program while actors prevail on the higher, more abstract layers.
*** Finally, it would be interesting to see how different actor libraries for the same language, for example Scala, affect the design decisions of programmers.
